\section{Test}
L'infrastruttura di test del progetto è stata sviluppata utilizzando \textbf{JUnit 5} per garantire l'affidabilità, la correttezza e la manutenibilità del codice. L'approccio segue una strategia multi-livello, suddividendo i test in tre categorie principali:

\begin{itemize}
	\item \textbf{Test Strutturali (Unit Test):} Focalizzati sulla verifica in \textbf{isolamento} dei singoli componenti (classi del Domain Model e logica di validazione dei Service), utilizzando \textit{mock object} per simulare le dipendenze esterne (come i DAO).

	\item \textbf{Test di Integrazione (ORM):} Mirati a validare la corretta comunicazione tra l'applicazione e il database PostgreSQL. Verificano l'intero ciclo di vita CRUD (Create, Read, Update, Delete) e la correttezza delle query SQL.

	\item \textbf{Test Funzionali:} Verificano una \textit{feature} completa "verticalmente" attraverso più layer (es. la generazione di un report), assicurando che il risultato finale sia corretto.
\end{itemize}

Per tutti i test che richiedono l'accesso al database, viene attivata una modalità di test (\texttt{DatabaseConnection.setTestMode(true)}) che reindirizza le operazioni verso un database di test dedicato, garantendo l'isolamento dall'ambiente di produzione.

\subsection{Test Strutturali (Unit Test)}
Questi test "white-box" verificano la logica interna dei componenti senza dipendere dal database o da altri servizi.

\subsubsection{Test del Domain Model}
I test sulle entità del \texttt{DomainModel}, come \texttt{PiantagioneTest}, sono i più semplici. Il loro scopo è validare l'integrità dei dati, il comportamento dei costruttori (Listing \ref{lst:pojo_test}) e la corretta implementazione di getter, setter e della logica di stato di default (es. lo stato \texttt{ATTIVA}).

\begin{lstlisting}[
    language=Java,
    caption={Test unitario per il costruttore e la logica di stato di default dell'entità Piantagione.},
    label={lst:pojo_test}
]
@Test
@DisplayName("Test costruttore vuoto")
void testCostruttoreVuoto() {
    Piantagione piantagione = new Piantagione();
    assertNotNull(piantagione);
    assertNull(piantagione.getId());
    
    // Verifica che lo stato di default sia 1 (ATTIVA)
    assertEquals(1, piantagione.getIdStatoPiantagione()); 
}

@Test
@DisplayName("Test gestione stato piantagione - Oggetto")
void testGestioneStatoOggetto() {
    StatoPiantagione statoTest = new StatoPiantagione(
        1, StatoPiantagione.ATTIVA, "Piantagione attiva");
        
    piantagione.setStatoPiantagione(statoTest);
    
    assertEquals(statoTest, piantagione.getStatoPiantagione());
    // Verifica che l'ID sia stato sincronizzato
    assertEquals(1, piantagione.getIdStatoPiantagione()); 
}
\end{lstlisting}

\subsubsection{Test dei Service (Logica di Validazione)}
Questa è la categoria di unit test più importante. Per testare la logica di business (principalmente la validazione) in \textbf{totale isolamento}, i \texttt{Service} vengono istanziati iniettando \textbf{Mock DAO}. Questi mock (Listing \ref{lst:mock_dao_test}) simulano il comportamento del database (es. restituendo liste vuote o assegnando ID fittizi) senza mai stabilire una connessione reale.

Questo approccio permette di testare in modo granulare ogni singola regola di validazione definita nei service, come mostrato nel Listing \ref{lst:service_validation_test}.

\begin{lstlisting}[
    language=Java,
    caption={Definizione di un Mock DAO interno alla classe di test per isolare il service.},
    label={lst:mock_dao_test}
]
// Mock DAO che simula successo nelle operazioni
static class MockPiantaDAO extends PiantaDAO {
    @Override
    public void create(Pianta pianta) {
        // Simula l'assegnazione di un ID dopo il salvataggio
        pianta.setId(1);
    }

    @Override
    public List<Pianta> findAll() {
        // Restituisce una lista vuota per evitare conflitti 
        return new java.util.ArrayList<>();
    }
    
    // ... altri metodi mockati ...
}

@BeforeEach
void setUp() {
    // Il Service viene istanziato con il MOCK, non con il DAO reale
    piantaService = new PiantaService(new MockPiantaDAO());
    // ...
}
\end{lstlisting}

\begin{lstlisting}[
    language=Java,
    caption={Esempi di test di validazione "white-box" su PiantaService.},
    label={lst:service_validation_test}
]
@Test
@DisplayName("Test aggiunta pianta con tipo vuoto")
void testAggiungiPiantaTipoVuoto() {
    piantaValida.setTipo("");
    ValidationException exception = assertThrows(ValidationException.class, () -> {
        piantaService.aggiungiPianta(piantaValida);
    });
    assertTrue(exception.getMessage().contains("Tipo"));
}

@Test
@DisplayName("Test aggiunta pianta con costo negativo")
void testAggiungiPiantaCostoNegativo() {
    piantaValida.setCosto(new BigDecimal("-1.00"));
    ValidationException exception = assertThrows(ValidationException.class, () -> {
        piantaService.aggiungiPianta(piantaValida);
    });
    assertTrue(exception.getMessage().contains("costo"));
}

@Test
@DisplayName("Test aggiunta pianta con fornitore ID nullo")
void testAggiungiPiantaFornitoreIdNull() {
    piantaValida.setFornitoreId(null);
    ValidationException exception = assertThrows(ValidationException.class, () -> {
        piantaService.aggiungiPianta(piantaValida);
    });
    assertTrue(exception.getMessage().contains("Fornitore"));
}
\end{lstlisting}

\subsection{Test di Integrazione (ORM e Database)}
Questi test validano l'intero strato \texttt{ORM}, assicurando che le classi DAO interagiscano correttamente con il database PostgreSQL. Testano la correttezza delle query SQL, la gestione delle \texttt{SQLException} e il mapping tra \texttt{ResultSet} e oggetti del dominio.

Per garantire che i test siano \textbf{idempotenti} (cioè eseguibili più volte senza alterare lo stato del sistema), viene utilizzata una strategia di \textit{setup} e \textit{teardown}:
\begin{itemize}
	\item \texttt{@BeforeAll}: Attiva la modalità test del database.
	\item \texttt{@BeforeEach}: Crea le entità necessarie (incluse le dipendenze da chiavi esterne, come \texttt{Fornitore} per \texttt{Pianta}) e le salva nel DB.
	\item \texttt{@AfterEach}: Elimina i dati creati durante il test, riportando il DB allo stato iniziale.
	\item \texttt{@AfterAll}: Disattiva la modalità test.
\end{itemize}

\begin{lstlisting}[
    language=Java,
    caption={Test di integrazione per il ciclo CRUD completo su PiantaDAO.},
    label={lst:crud_test}
]
@BeforeEach
void createTestObjects() throws SQLException {
    // 1. Crea la dipendenza (Fornitore)
    testFornitore = new Fornitore();
    testFornitore.setNome("Fornitore Piante Test");
    // ... (set altri campi)
    fornitoreDAO.create(testFornitore);

    // 2. Crea l'entità principale (Pianta)
    testPianta = new Pianta();
    testPianta.setTipo("Albero");
    testPianta.setFornitoreId(testFornitore.getId());
    piantaDAO.create(testPianta);
}

@AfterEach
void cleanUp() throws SQLException {
    // Pulisce in ordine inverso
    if (testPianta != null) { piantaDAO.delete(testPianta.getId()); }
    if (testFornitore != null) { fornitoreDAO.delete(testFornitore.getId()); }
}

@Test
@DisplayName("Test aggiornamento pianta")
void testUpdatePianta() throws SQLException {
    String nuovaVarieta = "Pero";
    testPianta.setVarieta(nuovaVarieta);

    // Azione: aggiorna
    piantaDAO.update(testPianta);

    // Assert: rilegge e verifica
    Pianta updated = piantaDAO.read(testPianta.getId());
    assertEquals(nuovaVarieta, updated.getVarieta());
}
\end{lstlisting}

\subsubsection{Test di Componenti Read-Only}
Una strategia di test specifica è stata usata per i DAO che implementano componenti "read-only" del sistema, come \texttt{StatoPiantagioneDAO}. In questo caso, i test non solo verificano le operazioni di lettura (es. \texttt{findByCodice}, \texttt{findAllOrdered}), ma validano esplicitamente che le operazioni di scrittura siano \textbf{bloccate}, assicurando che il test fallisca se un'operazione non supportata viene accidentalmente abilitata (Listing \ref{lst:readonly_test}).

\begin{lstlisting}[
    language=Java,
    caption={Test di sicurezza che verifica il blocco delle operazioni di scrittura su un DAO read-only.},
    label={lst:readonly_test}
]
@Test
@DisplayName("Test blocco operazione create")
void testCreateBlocked() {
    StatoPiantagione nuovoStato = new StatoPiantagione();
    nuovoStato.setCodice("TEST");
    
    assertThrows(UnsupportedOperationException.class, () -> {
        statoPiantagioneDAO.create(nuovoStato);
    }, "L'operazione create deve essere bloccata");
}

@Test
@DisplayName("Test blocco operazione update")
void testUpdateBlocked() {
    StatoPiantagione statoEsistente = new StatoPiantagione();
    statoEsistente.setId(1);
    
    assertThrows(UnsupportedOperationException.class, () -> {
        statoPiantagioneDAO.update(statoEsistente);
    }, "L'operazione update deve essere bloccata");
}
\end{lstlisting}

\subsection{Test Funzionali}
I test funzionali verificano una \textit{feature} completa (come un caso d'uso) eseguendo il codice attraverso più layer. A differenza dei test unitari, questi test non usano mock ma interagiscono con i servizi reali e il database di test per validare il risultato finale.

Il test \texttt{ReportServiceTest} è un esempio di questa strategia. Verifica che la generazione dei report (un'operazione complessa che richiede l'esecuzione di \texttt{Strategy} e l'accesso ai dati tramite il \texttt{RaccoltoService}) produca un risultato corretto.

Il test include anche logica condizionale: se il database di test non contiene dati di raccolto (\texttt{hasRaccoltiDisponibili()}), il test viene contrassegnato come \textit{skipped}, evitando falsi negativi e rendendo la suite di test più robusta.

\begin{lstlisting}[
    language=Java,
    caption={Test funzionale per la generazione di un report.},
    label={lst:functional_test}
]
@Test
@Order(2)
@DisplayName("Report completo con raccolti disponibili")
void testGeneraReportCompleto_ConDati() {
    testLogger.startTest("generaReportCompleto - con dati");

    try {
        // Verifica pre-condizione: ci sono dati?
        if (!reportService.hasRaccoltiDisponibili()) {
            testLogger.expectedError("Report completo", 
                "Nessun raccolto disponibile - test skipped");
            return; // Skip se non ci sono dati
        }

        // Azione: chiama la logica di business
        ProcessingResult<Map<String, Object>> result = 
            reportService.generaReportCompleto();

        // Assert: verifica il risultato
        assertNotNull(result, "Il risultato non dovrebbe essere null");
        assertNotNull(result.data(), "I dati del report non dovrebbero essere null");
        
        Map<String, Object> data = result.data();
        assertTrue(data.containsKey("statisticheGenerali") || !data.isEmpty(),
            "Il report dovrebbe contenere dati");

        testLogger.testPassed("generaReportCompleto - OK");

    } catch (BusinessLogicException | DataAccessException | ValidationException e) {
        testLogger.testFailed("generaReportCompleto", e.getMessage());
        fail("Errore durante generazione report: " + e.getMessage());
    }
}
\end{lstlisting}